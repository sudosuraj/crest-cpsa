/**
 * P2P Question Sync using Gun.js
 * 
 * Automatically syncs cached questions between students using a decentralized
 * peer-to-peer network. No manual link sharing required - all students using
 * the app automatically share their cached questions.
 * 
 * How it works:
 * 1. Gun.js creates a decentralized database that syncs across all peers
 * 2. When a student generates questions, they're automatically shared
 * 3. Other students receive these questions and cache them locally
 * 4. Questions are organized by appendix for efficient retrieval
 * 
 * This reduces API calls because students can use questions generated by others.
 * 
 * P2P is "best effort" - if relay servers are unavailable, the app works normally
 * without P2P sync. No console spam on connection failures.
 */

const P2PSync = (function() {
    'use strict';

    // Gun.js instance
    let gun = null;
    let isInitialized = false;
    let syncEnabled = true;
    let lastInitAttempt = 0;
    const INIT_THROTTLE_MS = 30000;
    
    // App namespace to avoid conflicts with other Gun apps
    const APP_NAMESPACE = 'cpsa-quiz-v2';
    
    // Standard cache options - MUST match QuestionCache defaults for cache key compatibility
    // v2: Updated to match new cache version with meta-question filtering
    const STANDARD_CACHE_OPTIONS = {
        model: 'gpt-4o-mini',
        promptVersion: 2,
        questionsPerChunk: 5
    };
    
    // Meta-question patterns to filter out - questions about syllabus structure
    const META_QUESTION_PATTERNS = [
        /primary focus of appendix/i,
        /missing from the official.*syllabus/i,
        /indicated as missing/i,
        /considered important in the context of.*certification/i,
        /inferred.*based on the.*study material/i,
        /true regarding the official.*syllabus/i,
        /what is appendix [a-j]/i,
        /which appendix/i,
        /the syllabus document/i,
        /the study material/i,
        /the provided material/i,
        /according to the.*material/i
    ];
    
    /**
     * Check if a question is about meta-content (syllabus structure, etc.)
     * @param {Object} question - The question to check
     * @returns {boolean} - True if question should be filtered out
     */
    function isMetaQuestion(question) {
        if (!question || !question.question) return true;
        
        const questionText = question.question;
        const explanationText = question.explanation || '';
        
        for (const pattern of META_QUESTION_PATTERNS) {
            if (pattern.test(questionText) || pattern.test(explanationText)) {
                console.log(`P2PSync: Filtering meta-question: ${questionText.substring(0, 60)}...`);
                return true;
            }
        }
        
        return false;
    }
    
    // Failure budget - disable P2P after too many failures
    const FAILURE_BUDGET = {
        maxFailures: 3,
        cooldownMs: 5 * 60 * 1000, // 5 minutes cooldown after failures
        failures: 0,
        lastFailure: 0,
        disabled: false
    };
    
    // Track what we've already synced to avoid duplicates
    const syncedQuestionHashes = new Set();
    
    // Current subscription (for lazy subscription)
    let currentAppendix = null;
    
    // Callbacks for when new questions arrive
    const questionListeners = [];
    
    // Presence tracking
    let presenceInterval = null;
    let onlineStudents = new Map();
    const PRESENCE_TTL = 60000;
    const PRESENCE_HEARTBEAT = 30000;
    let myPeerId = null;
    
    // Flagged questions
    const flaggedQuestions = new Map();
    const FLAG_THRESHOLD = 3;
    
    // Stats for debugging
    const stats = {
        questionsSent: 0,
        questionsReceived: 0,
        questionsUsedFromP2P: 0,
        peersConnected: 0,
        lastSync: null
    };
    
    function generatePeerId() {
        return 'peer_' + Date.now().toString(36) + '_' + Math.random().toString(36).substr(2, 9);
    }
    
    /**
     * Check if P2P is in cooldown due to failures
     */
    function isInCooldown() {
        if (!FAILURE_BUDGET.disabled) return false;
        const elapsed = Date.now() - FAILURE_BUDGET.lastFailure;
        if (elapsed > FAILURE_BUDGET.cooldownMs) {
            // Cooldown expired, reset and allow retry
            FAILURE_BUDGET.disabled = false;
            FAILURE_BUDGET.failures = 0;
            syncEnabled = true;
            return false;
        }
        return true;
    }
    
    /**
     * Record a connection failure
     */
    function recordFailure() {
        FAILURE_BUDGET.failures++;
        FAILURE_BUDGET.lastFailure = Date.now();
        if (FAILURE_BUDGET.failures >= FAILURE_BUDGET.maxFailures) {
            FAILURE_BUDGET.disabled = true;
            syncEnabled = false;
            // Stop presence heartbeat to prevent further connection attempts
            if (presenceInterval) {
                clearInterval(presenceInterval);
                presenceInterval = null;
            }
        }
    }

    // Default relay servers for P2P sync
    // These are community-run Gun.js relays - updated for reliability
    const DEFAULT_RELAY_SERVERS = [
        'https://relay.peer.ooo/gun',
        'https://gun-relay.meething.space/gun',
        'https://peer.wallie.io/gun'
    ];

    /**
     * Initialize Gun.js with public relay peers (lazy - only when needed)
     * This is "best effort" - failures are silent and don't spam console
     */
    function initialize() {
        // Already initialized
        if (isInitialized) {
            return Promise.resolve(true);
        }
        
        // In cooldown due to failures
        if (isInCooldown()) {
            return Promise.resolve(false);
        }
        
        // Throttle initialization attempts to prevent spam
        const now = Date.now();
        if (now - lastInitAttempt < INIT_THROTTLE_MS) {
            return Promise.resolve(false);
        }
        
        // Check if online
        if (typeof navigator !== 'undefined' && !navigator.onLine) {
            return Promise.resolve(false);
        }

        lastInitAttempt = now;

        return new Promise((resolve) => {
            try {
                if (typeof Gun === 'undefined') {
                    // Gun.js not loaded - this is fine, P2P is optional
                    recordFailure();
                    resolve(false);
                    return;
                }

                myPeerId = generatePeerId();

                // Initialize Gun WITH relay peers for actual P2P sync
                // This enables cross-user question sharing
                gun = Gun({
                    peers: DEFAULT_RELAY_SERVERS,
                    localStorage: false,
                    radisk: false
                });

                isInitialized = true;
                syncEnabled = true;
                
                // Reset failure budget on successful init
                FAILURE_BUDGET.failures = 0;
                FAILURE_BUDGET.disabled = false;
                
                // Start presence heartbeat and flag listener
                startPresenceHeartbeat();
                startFlagListener();
                
                console.log('P2PSync: Initialized with relay servers');
                resolve(true);
            } catch (error) {
                // Record failure and allow retry after cooldown
                console.warn('P2PSync: Initialization failed', error);
                recordFailure();
                resolve(false);
            }
        });
    }
    
    /**
     * Try to connect to additional relay servers (best effort, no console spam)
     */
    function tryConnectToRelays(customRelays) {
        if (!gun || isInCooldown()) return;
        
        const relayUrls = customRelays || DEFAULT_RELAY_SERVERS;
        
        // Gun handles connection attempts internally
        // We just add the peers and let Gun manage connections
        relayUrls.forEach(url => {
            try {
                gun.opt({ peers: [url] });
            } catch (e) {
                // Silent failure
            }
        });
    }
    
    /**
     * Subscribe to questions for a specific appendix (lazy subscription)
     * Self-sufficient: automatically initializes P2P if not already done
     */
    async function subscribeToAppendix(appendixLetter) {
        // Auto-initialize if not already done (lazy initialization)
        if (!isInitialized) {
            const initialized = await initialize();
            if (!initialized) {
                console.log('P2PSync: Could not initialize, skipping subscription');
                return;
            }
        }
        
        if (!gun || !syncEnabled) return;
        if (currentAppendix === appendixLetter) return;
        
        if (currentAppendix) {
            console.log('P2PSync: Switching from Appendix ' + currentAppendix + ' to ' + appendixLetter);
        }
        
        currentAppendix = appendixLetter;
        console.log('P2PSync: Subscribing to Appendix ' + appendixLetter);
        
        const path = APP_NAMESPACE + '/questions/' + appendixLetter;
        
        gun.get(path).map().on((data, chunkId) => {
            if (!data || !chunkId || currentAppendix !== appendixLetter) return;
            processReceivedChunk(data, chunkId, appendixLetter);
        });
        
        updatePresence();
    }
    
    /**
     * Process a received chunk of questions from P2P
     */
    async function processReceivedChunk(data, chunkId, appendixLetter) {
        try {
            const chunkData = typeof data === 'string' ? JSON.parse(data) : data;
            
            if (!chunkData || !chunkData.questions || !Array.isArray(chunkData.questions)) {
                return;
            }
            
            // Filter out invalid questions and meta-questions (about syllabus structure, etc.)
            const validQuestions = chunkData.questions.filter(q => 
                validateQuestion(q) && !isMetaQuestion(q)
            );
            if (validQuestions.length === 0) return;
            
            // Check if we already have this chunk cached
            if (typeof QuestionCache !== 'undefined') {
                const existing = await QuestionCache.get(chunkId, STANDARD_CACHE_OPTIONS);
                if (existing && existing.length >= validQuestions.length) {
                    return;
                }
            }
            
            // Enrich and cache questions
            const enrichedQuestions = validQuestions.map(q => ({
                question: q.question,
                options: q.options,
                correct: q.correct,
                explanation: q.explanation || '',
                section_id: q.section_id || chunkData.sectionId || '',
                section_title: q.section_title || '',
                source_chunk_id: chunkId,
                appendix: appendixLetter,
                fromP2P: true
            }));
            
            if (typeof QuestionCache !== 'undefined') {
                await QuestionCache.set(chunkId, enrichedQuestions, {
                    appendix: appendixLetter,
                    sectionId: chunkData.sectionId || ''
                }, STANDARD_CACHE_OPTIONS);
                
                stats.questionsReceived += enrichedQuestions.length;
                stats.lastSync = new Date().toISOString();
                console.log('P2PSync: Cached ' + enrichedQuestions.length + ' questions for chunk ' + chunkId);
            }
            
            // Notify listeners
            enrichedQuestions.forEach(q => {
                const hash = hashQuestion(q.question);
                if (!syncedQuestionHashes.has(hash)) {
                    syncedQuestionHashes.add(hash);
                    questionListeners.forEach(listener => {
                        try { listener(q, appendixLetter); } catch (e) {}
                    });
                }
            });
        } catch (e) {
            console.warn('P2PSync: Error processing chunk', e);
        }
    }
    
    /**
     * Validate a question has required fields
     */
    function validateQuestion(q) {
        if (!q || typeof q !== 'object') return false;
        if (!q.question || typeof q.question !== 'string') return false;
        if (!q.options || !Array.isArray(q.options) || q.options.length !== 4) return false;
        if (typeof q.correct !== 'number' || q.correct < 0 || q.correct > 3) return false;
        if (q.question.length > 1000) return false;
        if (q.options.some(opt => typeof opt !== 'string' || opt.length > 500)) return false;
        return true;
    }

    // ==================== PRESENCE TRACKING ====================
    
    function startPresenceHeartbeat() {
        if (!gun || presenceInterval) return;
        
        updatePresence();
        presenceInterval = setInterval(updatePresence, PRESENCE_HEARTBEAT);
        
        gun.get(APP_NAMESPACE + '/presence').map().on((data, peerId) => {
            if (!data || peerId === myPeerId) return;
            try {
                const presence = typeof data === 'string' ? JSON.parse(data) : data;
                const now = Date.now();
                if (presence.timestamp && (now - presence.timestamp) < PRESENCE_TTL) {
                    onlineStudents.set(peerId, presence);
                } else {
                    onlineStudents.delete(peerId);
                }
                stats.peersConnected = onlineStudents.size;
            } catch (e) {}
        });
        
        setInterval(() => {
            const now = Date.now();
            onlineStudents.forEach((presence, peerId) => {
                if (now - presence.timestamp > PRESENCE_TTL) {
                    onlineStudents.delete(peerId);
                }
            });
            stats.peersConnected = onlineStudents.size;
        }, PRESENCE_TTL);
        
        console.log('P2PSync: Presence tracking started');
    }
    
    function updatePresence() {
        if (!gun || !myPeerId) return;
        gun.get(APP_NAMESPACE + '/presence').get(myPeerId).put(JSON.stringify({
            timestamp: Date.now(),
            appendix: currentAppendix || null
        }));
    }
    
    function getOnlineCount() {
        return onlineStudents.size + 1;
    }
    
    function getOnlinePeers() {
        const peers = [];
        onlineStudents.forEach((presence, peerId) => {
            peers.push({ peerId, appendix: presence.appendix, lastSeen: presence.timestamp });
        });
        return peers;
    }
    
    function getPeersOnSameAppendix() {
        if (!currentAppendix) return 0;
        let count = 0;
        onlineStudents.forEach(presence => {
            if (presence.appendix === currentAppendix) count++;
        });
        return count;
    }
    
    // ==================== COLLABORATIVE FLAGGING ====================
    
    function startFlagListener() {
        if (!gun) return;
        gun.get(APP_NAMESPACE + '/flags').map().on((data, questionHash) => {
            if (!data || !questionHash) return;
            try {
                const flagData = typeof data === 'string' ? JSON.parse(data) : data;
                if (flagData.reporters && Array.isArray(flagData.reporters)) {
                    flaggedQuestions.set(questionHash, {
                        count: flagData.reporters.length,
                        reporters: new Set(flagData.reporters),
                        reason: flagData.reason || 'Incorrect'
                    });
                }
            } catch (e) {}
        });
    }
    
    function flagQuestion(questionText, reason = 'Incorrect') {
        if (!gun || !myPeerId || !questionText) return false;
        
        const questionHash = hashQuestion(questionText);
        const existing = flaggedQuestions.get(questionHash) || { count: 0, reporters: new Set() };
        
        if (existing.reporters.has(myPeerId)) {
            console.log('P2PSync: Already flagged this question');
            return false;
        }
        
        existing.reporters.add(myPeerId);
        existing.count = existing.reporters.size;
        existing.reason = reason;
        flaggedQuestions.set(questionHash, existing);
        
        gun.get(APP_NAMESPACE + '/flags').get(questionHash).put(JSON.stringify({
            reporters: Array.from(existing.reporters),
            reason: reason,
            updatedAt: Date.now()
        }));
        
        console.log('P2PSync: Flagged question (' + existing.count + ' total flags)');
        return true;
    }
    
    function isQuestionFlagged(questionText) {
        const questionHash = hashQuestion(questionText);
        const flagData = flaggedQuestions.get(questionHash);
        return flagData && flagData.count >= FLAG_THRESHOLD;
    }
    
    function getFlagCount(questionText) {
        const questionHash = hashQuestion(questionText);
        const flagData = flaggedQuestions.get(questionHash);
        return flagData ? flagData.count : 0;
    }
    
        // ==================== P2P-FIRST POLICY ====================
    
        /**
         * Wait for P2P questions with timeout
         * This function waits for Gun.js data to arrive before returning
         * @param {string} appendixLetter - The appendix to get questions for
         * @param {Object} options - Options: minCount (minimum questions needed), timeoutMs (max wait time)
         */
        async function getQuestionsFromPool(appendixLetter, options = {}) {
            const { minCount = 5, timeoutMs = 2000 } = options;
        
            // Auto-initialize if not already done
            if (!isInitialized) {
                await initialize();
            }
        
            if (!gun || !syncEnabled) return [];
        
            // Subscribe to appendix (sets up Gun.js listener)
            if (currentAppendix !== appendixLetter) {
                await subscribeToAppendix(appendixLetter);
            }
        
            // Wait for P2P data to arrive with timeout
            // Gun.js data arrives asynchronously via processReceivedChunk
            const startTime = Date.now();
            let lastCount = 0;
        
            while (Date.now() - startTime < timeoutMs) {
                if (typeof QuestionCache !== 'undefined') {
                    try {
                        const cached = await QuestionCache.getAllQuestionsForAppendix(appendixLetter);
                        const p2pQuestions = cached.filter(q => q.fromP2P);
                    
                        // If we have enough P2P questions, return immediately
                        if (p2pQuestions.length >= minCount) {
                            stats.questionsUsedFromP2P = p2pQuestions.length;
                            console.log('P2PSync: Found ' + p2pQuestions.length + ' P2P questions for Appendix ' + appendixLetter);
                            return cached;
                        }
                    
                        // If count increased, log progress
                        if (p2pQuestions.length > lastCount) {
                            console.log('P2PSync: Receiving questions... ' + p2pQuestions.length + '/' + minCount);
                            lastCount = p2pQuestions.length;
                        }
                    } catch (e) {
                        console.warn('P2PSync: Error checking cache', e);
                    }
                }
            
                // Wait a bit before checking again
                await new Promise(resolve => setTimeout(resolve, 200));
            }
        
            // Timeout reached - return whatever we have
            if (typeof QuestionCache !== 'undefined') {
                try {
                    const cached = await QuestionCache.getAllQuestionsForAppendix(appendixLetter);
                    const p2pCount = cached.filter(q => q.fromP2P).length;
                    stats.questionsUsedFromP2P = p2pCount;
                    console.log('P2PSync: Timeout reached, returning ' + p2pCount + ' P2P questions');
                    return cached;
                } catch (e) {
                    console.warn('P2PSync: Error getting cached questions', e);
                }
            }
            return [];
        }

    /**
     * Share questions by chunk (groups questions by source_chunk_id)
     * This ensures P2P questions are stored under correct cache keys
     * Auto-initializes P2P if not already done
     */
    async function shareChunkQuestions(questions, chunkId, appendixLetter, sectionId) {
        // Auto-initialize if not already done
        if (!isInitialized) {
            await initialize();
        }
        
        if (!gun || !syncEnabled || !questions || !chunkId) return;
        if (!Array.isArray(questions) || questions.length === 0) return;
        
        try {
            // Filter out already-shared questions
            const newQuestions = questions.filter(q => {
                const hash = hashQuestion(q.question || '');
                if (syncedQuestionHashes.has(hash)) return false;
                syncedQuestionHashes.add(hash);
                return true;
            });
            
            if (newQuestions.length === 0) return;
            
            // Create chunk data for sharing
            const chunkData = {
                questions: newQuestions.map(q => ({
                    question: q.question,
                    options: q.options,
                    correct: q.correct,
                    explanation: q.explanation || '',
                    section_id: q.section_id || sectionId || '',
                    section_title: q.section_title || ''
                })),
                sectionId: sectionId || '',
                sharedAt: Date.now()
            };
            
            // Store in Gun under appendix/chunkId path
            const path = APP_NAMESPACE + '/questions/' + appendixLetter;
            gun.get(path).get(chunkId).put(JSON.stringify(chunkData));
            
            stats.questionsSent += newQuestions.length;
            stats.lastSync = new Date().toISOString();
            
            console.log('P2PSync: Shared ' + newQuestions.length + ' questions for chunk ' + chunkId);
        } catch (error) {
            console.warn('P2PSync: Failed to share chunk questions', error);
        }
    }
    
    /**
     * Share multiple questions (groups by source_chunk_id automatically)
     * Auto-initializes P2P if not already done
     */
    async function shareQuestions(questions, appendixLetter) {
        if (!Array.isArray(questions) || questions.length === 0) return;
        
        // Group questions by source_chunk_id
        const byChunk = new Map();
        questions.forEach(q => {
            const chunkId = q.source_chunk_id || (appendixLetter + '_unknown');
            if (!byChunk.has(chunkId)) {
                byChunk.set(chunkId, { questions: [], sectionId: q.section_id || '' });
            }
            byChunk.get(chunkId).questions.push(q);
        });
        
        // Share each chunk
        for (const [chunkId, data] of byChunk) {
            await shareChunkQuestions(data.questions, chunkId, appendixLetter, data.sectionId);
        }
    }
    
    /**
     * Share a single question (wraps shareChunkQuestions)
     * Auto-initializes P2P if not already done
     */
    async function shareQuestion(question, appendixLetter) {
        if (!question) return;
        const chunkId = question.source_chunk_id || (appendixLetter + '_unknown');
        await shareChunkQuestions([question], chunkId, appendixLetter, question.section_id);
    }

    /**
     * Simple hash function for question deduplication
     */
    function hashQuestion(text) {
        if (!text) return '0';
        const normalized = text.toLowerCase().replace(/[^\w\s]/g, '').replace(/\s+/g, ' ').trim();
        let hash = 2166136261;
        for (let i = 0; i < normalized.length; i++) {
            hash ^= normalized.charCodeAt(i);
            hash = (hash * 16777619) >>> 0;
        }
        return hash.toString(16);
    }

    /**
     * Register a callback for when new questions arrive from peers
     * @param {Function} callback - Called with (question, appendix) when new question arrives
     */
    function onQuestionReceived(callback) {
        if (typeof callback === 'function') {
            questionListeners.push(callback);
        }
    }

    /**
     * Remove a question listener
     */
    function offQuestionReceived(callback) {
        const index = questionListeners.indexOf(callback);
        if (index > -1) {
            questionListeners.splice(index, 1);
        }
    }

    /**
     * Get sync statistics
     */
    function getStats() {
        return { ...stats, syncEnabled, isInitialized };
    }

    /**
     * Enable or disable P2P sync
     */
    function setEnabled(enabled) {
        syncEnabled = enabled;
        console.log(`P2PSync: ${enabled ? 'Enabled' : 'Disabled'}`);
    }

    /**
     * Check if P2P sync is available and enabled
     */
    function isAvailable() {
        return isInitialized && syncEnabled;
    }
    
    /**
     * Manually enable relay connections (for power users)
     * Call this from browser console: P2PSync.enableRelays()
     * Note: Relay servers may be unreliable and cause WebSocket errors
     */
    function enableRelays(customRelays) {
        if (!gun) {
            console.warn('P2PSync: Gun not initialized. Call P2PSync.initialize() first.');
            return false;
        }
        
        const relayUrls = customRelays || [
            'https://gun-manhattan.herokuapp.com/gun',
            'https://gun-us.herokuapp.com/gun'
        ];
        
        console.log('P2PSync: Attempting to connect to relays:', relayUrls);
        
        relayUrls.forEach(url => {
            try {
                gun.opt({ peers: [url] });
            } catch (e) {
                console.warn('P2PSync: Failed to add relay:', url, e);
            }
        });
        
        return true;
    }

    // Public API
    return {
        initialize,
        subscribeToAppendix,
        shareQuestion,
        shareQuestions,
        shareChunkQuestions,
        getQuestionsFromPool,
        onQuestionReceived,
        offQuestionReceived,
        getStats,
        setEnabled,
        isAvailable,
        getOnlineCount,
        getOnlinePeers,
        getPeersOnSameAppendix,
        flagQuestion,
        isQuestionFlagged,
        getFlagCount,
        enableRelays
    };
})();

// P2P is initialized lazily when first needed (e.g., when subscribing to an appendix)
// This prevents connection attempts on page load and reduces console errors
